import fs from "fs";
import path from "path";

function section(title, body) {
  return [`## ${title}`, body.trimEnd(), ""].join("\n");
}

export function generateReadmeContent(projectName, envReport, featureNotes = []) {
  const intro = [
    `# ${projectName}`,
    "",
    "This README was generated by the MiniPhi get-started sample.",
    "Update the following sections as the prompts teach MiniPhi new capabilities for your workspace.",
    "",
  ].join("\n");

  const environmentLines = [
    `- **Platform**: ${envReport.platform} ${envReport.release}`,
    `- **Architecture**: ${envReport.arch}`,
    `- **Node.js**: ${envReport.nodeVersion}`,
    `- **CPUs**: ${envReport.cpuCount}`,
    `- **Memory**: ${envReport.memoryGB} GB`,
    "",
    "### Tools",
  ];

  envReport.tools.forEach((tool) => {
    const status = tool.available ? `available (${tool.version})` : "missing";
    environmentLines.push(`- ${tool.name}: ${status}`);
  });

  const todoLines = [
    "- [ ] Replace this checklist with project-specific onboarding tasks.",
    "- [ ] Outline the preferred development workflow (tests, linters, analyzers).",
    "- [ ] Document any secrets or API keys that must be configured locally.",
  ];

  const featureDetails =
    featureNotes.length > 0
      ? featureNotes.map((note) => `- ${note}`).join("\n")
      : "- Feature telemetry not yet documented.";

  const body = [
    intro,
    section("Environment", environmentLines.join("\n")),
    section("Feature highlights", featureDetails),
    section("Next steps", todoLines.join("\n")),
  ];

  return body.join("\n").trim() + "\n";
}

export function writeReadme(targetDir, content) {
  const outputPath = path.resolve(targetDir);
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, content, "utf8");
  return outputPath;
}
